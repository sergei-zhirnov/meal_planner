<h2>ArrayList</h2>
<div class="step-text">
<h5 id="resizable-arrays">Resizable arrays</h5>
<p>One of the most widely used classes of Java Class Library is a class named <code class="language-java">ArrayList</code> that represents a resizable array of objects of a specified type. Unlike the standard array denoted as <code class="language-java">[]</code>, it can dynamically grow after the addition and shrink after the removal of its elements. This behavior is very useful if you do not know the size of the array in advance or you need one that can change size over the lifetime of a program.</p>
<p>In fact, this class is built on top of a standard Java array, extending it with a set of convenient <a class="theory-lookup" href="/learn/step/17081" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an operation is a function or method that performs a specific task on data. | In the context of streams, operations are categorized into intermediate and terminal. Intermediate operations, such as filter, map, and distinct, return a new stream and can be chained. Terminal operations, such as forEach and reduce, return a result or side effect and signal the end of the stream pipeline. Additionally, operations can be classified as filtering, mapping/modifying, or reducing/combining, with examples including distinct, sorted, and min. These concepts are essential for processing data effectively with streams in Java.">operations</a>. Like a standard array, it allows getting the current number of elements (its size) as well as accessing its elements by their indexes.</p>
<p>There is only one restriction to <code class="language-java">ArrayList</code>: being a <a class="theory-lookup" href="/learn/step/3492" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a generic class is a class that is parameterized over a type, allowing it to handle different data types in a uniform manner. | The type parameter is specified within angle brackets following the class name, and it can be used within the class body for fields, method arguments, return values, and local variables. The concrete type is determined when an object of the class is created or a method is invoked. Only reference types, such as arrays, standard classes, or custom classes, can be used as concrete types for generic classes. This approach enables the writing of more abstract and reusable code, as the same class or method can process multiple types in the same way.">generic class</a>, it cannot store <a class="theory-lookup" href="/learn/step/5035" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a primitive type is one of eight built-in data types provided by the language. | They are represented by keywords and are not objects, unlike reference types. Primitive types are divided into groups based on their meaning, and each group operates similarly but has different sizes and ranges of value. The most commonly used primitive type is `int`, which represents an integer number. Java also provides several types for integer and fractional numbers, which are often used in arithmetic expressions. Primitive types store their value directly, unlike reference types that store a reference to an object located elsewhere.">primitive types</a>. However, it can store any <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a reference type is a type of variable that stores a reference to an object located elsewhere in memory, rather than storing the object's value directly. | When an object is created using the new operator, it returns a reference to the location of the object in memory, allowing access to its fields and methods. Reference types can be assigned to variables, passed as arguments to methods, and returned as values from methods. They are important for creating complex, object-oriented programs in Java. Unlike primitive types, which store their values directly, reference types store a reference to an object. When comparing reference types using the == operator, it compares the references (memory addresses) rather than the actual values. Additionally, assigning one value of a reference variable to another creates a copy of the reference, rather than the value itself. Reference types can also refer to a special value that represents the fact that it is not initialized yet or does not have a value. It is important to note that in Java, the heap is the region of memory where objects are stored and allocated dynamically during runtime.">reference type</a>, including <code class="language-java">String</code>s, <a class="theory-lookup" href="/learn/step/3770" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a wrapper class is a class that encapsulates a primitive type in an object. | There are eight wrapper classes in Java, one for each primitive type: Integer for int, Double for double, Character for char, and so on. Wrapper classes are immutable and can be used in situations where objects are required instead of primitive types. Boxing is the process of converting a primitive type to an object of the corresponding wrapper class, while unboxing is the reverse process. Autoboxing and auto-unboxing are automatic conversions performed by the Java compiler between primitive types and wrapper classes.">wrapper classes</a> (like <code class="language-java">Integer</code>s), other <code class="language-java">ArrayList</code>s, and custom classes.</p>
<h5 id="creating-an-instance-of-arraylist">Creating an instance of ArrayList</h5>
<p>To start using the class by its short name, make the following import:</p>
<pre><code class="language-java">import java.util.ArrayList;</code></pre>
<p>Let's consider several ways to create instances of this class.</p>
<p>1) The simplest way is to use a <a class="theory-lookup" href="/learn/step/3535" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a no-argument constructor is a constructor that takes no arguments and is used to initialize the instance variables of a class with their default values. | If a class does not define any constructor, the Java compiler automatically provides a default no-argument constructor. However, if a class defines any specific constructor, the default no-argument constructor will not be created.">no-argument constructor</a>:</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></pre>
<p>The created list is empty, but its initial capacity is 10 (by default).</p>
<p>2) We can also specify its initial <a class="theory-lookup" href="/learn/step/3812" rel="noopener noreferrer nofollow" target="_blank" title="In Java, capacity refers to the amount of storage available for newly inserted elements in a data structure, such as a string or a list. | It determines the maximum number of elements that can be stored before an allocation is needed. The capacity can be specified when creating an object, but it can also change dynamically as elements are added or removed. For example, in the case of a list, the capacity will increase when the number of elements exceeds a certain threshold calculated as the current capacity multiplied by the load factor.">capacity</a>:</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(50);</code></pre>
<p>This list is empty, but its initial capacity is set to 50.</p>
<p>3) Or you can construct an <code class="language-java">ArrayList</code> that consists of elements of another list:</p>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(anotherList);</code></pre>
<p>Regardless of how you create an instance of <code class="language-java">ArrayList</code>, its size will dynamically change. In this lesson, we will create a list with the default capacity like in the first example.</p>
<p> </p>
<p></p>
<div class="alert alert-primary"><p>If you are an advanced user, you know that it is better to create and use an <code class="language-java">ArrayList</code> via its <code class="language-java">List</code> interface. We will do it in the next lessons after learning about <strong>inheritance</strong>. We believe that the current approach is enough for now since it requires less knowledge to start using dynamic collections.</p></div>
<p></p>
<p> </p>
<h5 id="basic-methods">Basic methods</h5>
<p>The collection has a set of convenient methods that emulate and extend the functionality of standard arrays. Let's discuss what they are. First, let's initialize some collections:</p>
<pre><code class="language-java">ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); // empty collection of strings</code></pre>
<p>First of all, there's a method to determine the size of the collection <code class="language-java">size</code> that returns the number of elements of the list. Let's try learning the size of ours:</p>
<pre><code class="language-java">System.out.println(names.size()); // 0</code></pre>
<p>As expected, it is empty and the result is zero. We also might want to learn the value of a specified position of an object. For that, collections have a <code class="language-java">get(int index)</code> method that returns the object of the list which is present at the specified index.</p>
<p>Next, there are a bunch of methods to add elements and set values of a collection:</p>
<ul><li><p><code class="language-java">add(Object o)</code> adds a passed element to the last position of the collection;</p></li><li><p><code class="language-java">add(int index, Object o)</code> adds a passed element to the specified position of the collection;</p></li><li><p><code class="language-java">set(int index, Object o)</code> replaces the element present at the specified index with the object;</p></li></ul>
<p>Let's add some names to our collection:</p>
<pre><code class="language-java">names.add("Justin");      // [Justin]
names.add("Helen");       // [Justin, Helen]
names.add(1, "Joshua");   // [Justin, Joshua, Helen]
names.add(0, "Laura");    // [Laura, Justin, Joshua, Helen]</code></pre>
<p>And replace one name with another:</p>
<pre><code class="language-java">names.set(3, "Marie"); // now: [Laura, Justin, Joshua, Marie]</code></pre>
<p>We can check that everything is as expected:</p>
<pre><code class="language-java">System.out.println(names);        // [Laura, Justin, Joshua, Marie]
System.out.println(names.size()); // 4
System.out.println(names.get(0)); // the first element is "Laura"
System.out.println(names.get(3)); // the last element is "Marie"</code></pre>
<p>Finally, there are methods for removing elements from the collection:</p>
<ul><li><p><code class="language-java">remove(Object o)</code> removes <strong>the first occurrence</strong> of the specified element from this list, if it is present;</p></li><li><p><code class="language-java">remove(int index)</code> removes the element at the specified position in this list;</p></li><li><p><code class="language-java">clear()</code> removes all elements from the collection.</p></li></ul>
<p>Let's try removing elements by value and index:</p>
<pre><code class="language-java">names.remove("Justin"); // [Laura, Joshua, Marie]
names.remove(1);        // [Laura, Marie]
names.clear();          // []</code></pre>
<p> </p>
<p></p>
<div class="alert alert-warning"><p>Important: indexes of elements start with 0 just like for standard arrays</p></div>
<p></p>
<p> </p>
<p>Try to play with this code by yourself and enjoy the power of <code class="language-java">ArrayList</code> . </p>
<h5 id="more-arraylist-methods">More ArrayList methods</h5>
<p>We've illustrated the possibilities of basic methods for collections in Java applied to an <code class="language-java">ArrayList</code> object. But this class has some more methods of its own. First, let's create another <code class="language-java">ArrayList</code>:</p>
<pre><code class="language-java">/* an ArrayList of Integers, not ints */
ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();

numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(1);</code></pre>
<p>There's also an <code class="language-java">addAll(Collection c)</code> method for adding a whole collection to an <code class="language-java">ArrayList</code>.  It appends elements of the provided collection to the end of the list:</p>
<pre><code class="language-java">ArrayList&lt;Integer&gt; numbers2 = new ArrayList&lt;&gt;();    // creating another list of Integers
numbers2.add(100);
numbers2.addAll(numbers); // [100, 1, 2, 3, 1]</code></pre>
<p>The class also has a method called <code class="language-java">contains</code> that checks whether a list contains a value or not, and two methods <code class="language-java">indexOf </code>and<code class="language-java">lastIndexOf</code> that find the index of the first and the last occurrences of an element, respectively. They <a class="theory-lookup" href="/learn/step/10982" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a return is a statement that ends the execution of a method and specifies a value to be returned to the caller. | The return type of a method defines what type of value can be returned. If a method has a return type of void, it means that the method does not return any value. However, you can still use the return statement to exit the method. If a method with a void return type tries to return a value, a compile error will occur.">return</a> <code class="language-java">-1</code> if there is no such element.</p>
<p>Let's see:</p>
<pre><code class="language-java">System.out.println(numbers2.contains(2));    // true
System.out.println(numbers2.contains(4));    // false
System.out.println(numbers2.indexOf(1));     // 1
System.out.println(numbers2.lastIndexOf(1)); // 4
System.out.println(numbers2.lastIndexOf(4)); // -1</code></pre>
<p>As you see, this class provides a rich set of methods to work with elements. You do not have to write them by yourself, as you do for standard arrays.</p>
<h5 id="iterating-over-arraylist">Iterating over ArrayList</h5>
<p>It is possible to <a class="theory-lookup" href="/learn/step/3602" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an iterator is an object that enables you to traverse through a collection of elements and access them sequentially. | It is like a moveable pointer to an element of the collection. Iterators allow you to remove elements from the underlying collection, but this cannot be done using a for-each loop. The iterator interface includes methods such as hasNext() to check if the iteration has more elements, next() to return the next element in the iteration, and remove() to delete the current element in the iteration.">iterate</a> over elements of an instance of the class. It is done in the same way as iterating over an array. In the following example, we use <em>for </em>and <em>for-each</em> loops to add the five first powers of ten in a list and then print the numbers to the standard output.</p>
<pre><code class="language-java">ArrayList&lt;Long&gt; powersOfTen = new ArrayList&lt;&gt;();

int count = 5;
for (int i = 0; i &lt; count; i++) {
    long power = (long) Math.pow(10, i);
    powersOfTen.add(power);
}

for (Long value : powersOfTen) {
    System.out.print(value + " ");
}</code></pre>
<p>The code prints the following:</p>
<pre><code class="language-java">1 10 100 1000 10000 
</code></pre>
<p>It is not harder than using a standard array.</p>
<h5 id="conclusion">Conclusion</h5>
<p>We've considered the <code class="language-java">ArrayList</code> class from the <code class="language-java">java.util</code> package. This class is similar to standard Java arrays but has the possibility to dynamically change its size. It has methods to get the size, add, remove and access elements by their indexes. In addition, <code class="language-java">ArrayList</code> provides a set of useful methods that check whether an element is present in the array and find it. A regular array does not have such methods built in.</p>
</div>
