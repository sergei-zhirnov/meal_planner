<h2>The Collections framework overview</h2>
<div class="step-text">
<p>Java provides the <strong>collections framework</strong> which consists of classes and interfaces for commonly reused data structures such as lists, dynamic arrays, <a class="theory-lookup" href="/learn/step/36432" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a set is a collection of unique elements, similar to a mathematical set. | It is fundamentally different from arrays or lists because it is not possible to access an element by its index. Sets are used when you need to keep only unique elements within a collection, get rid of duplicates in a sequence, or perform mathematical operations. The Java Collection Framework provides the Set interface to represent a set as an abstract data type. Some commonly used set implementations include HashSet, LinkedHashSet, and TreeSet, which are mutable and have different rules for ordering elements and are optimized for different types of operations. Immutable sets, whose names are not important for programmers, also implement the Set interface.">sets</a>, and so on. The framework has a unified architecture for representing and manipulating collections, enabling collections to be used independently of implementation details via their interfaces.</p>
<p>The framework includes:</p>
<ul><li><p>interfaces that represent different types of collections;</p></li><li><p>primary implementations of the interfaces;</p></li><li><p>legacy implementations from earlier releases (known as "old collections");</p></li><li><p>special-purpose implementations (like <a class="theory-lookup" href="/learn/step/3573" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an immutable collection is a collection that cannot be modified once it is created. | Any attempt to modify the collection will result in a Java.lang.UnsupportedOperationException. This is because immutable collections return a read-only view of the original collection. They implement the same interface as mutable collections, but their implementation does not allow for modification. This is useful in situations where you want to ensure that the collection remains constant and cannot be modified by other parts of the program.">immutable collections</a>);</p></li><li><p><a class="theory-lookup" href="/learn/step/3556" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an algorithm is a set of instructions, written in the form of code, to solve a specific problem or perform a particular task. | The Strategy pattern in Java encapsulates a family of algorithms, each in a separate class, making them interchangeable within that family. This allows for easier addition of new algorithms and more concise code. The algorithm executed in different branches are moved into their own class, and a common interface is determined for a family of algorithms, which should contain one or more abstract methods.">algorithms</a> represented by <a class="theory-lookup" href="/learn/step/3534" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a static method is a method that is associated with a class rather than an instance of a class. | It can be accessed directly using the class name and does not require the creation of a class instance. A static method can only access static fields and other static methods within the same class, and cannot refer to the `this` keyword because there is no instance context. Static methods are often used as utility methods that provide common functionality for the entire project. They can be called from instance methods, but not the other way around.">static methods</a> that perform useful <a class="theory-lookup" href="/learn/step/17081" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an operation is a function or method that performs a specific task on data. | In the context of streams, operations are categorized into intermediate and terminal. Intermediate operations, such as filter, map, and distinct, return a new stream and can be chained. Terminal operations, such as forEach and reduce, return a result or side effect and signal the end of the stream pipeline. Additionally, operations can be classified as filtering, mapping/modifying, or reducing/combining, with examples including distinct, sorted, and min. These concepts are essential for processing data effectively with streams in Java.">operations</a> on collections.</p></li></ul>
<p>In this topic, we will only consider the basic interfaces from<em> </em>the collections framework placed in the <code class="language-java">java.util</code> package.</p>
<h5 id="commonly-used-interfaces">Commonly used interfaces</h5>
<p>There are two root generic interfaces <code class="language-java">Collection&lt;E&gt;</code> and <code class="language-java">Map&lt;K,V&gt;</code>, and some more specific interfaces to represent different types of collections.</p>
<p style="text-align: center;"><strong><picture><img alt="The collections framework hierarchy" height="414" src="https://ucarecdn.com/7592c5a5-1adb-4f91-8a83-15e0c6dfbe4b/" width="746"/></picture></strong></p>
<p>The interface <code class="language-java">Collection&lt;E&gt;</code> represents an abstract collection, which is a container for objects of the same type. It provides some common methods for all other types of collections.</p>
<p>The interfaces <code class="language-java">List&lt;E&gt;</code>, <code class="language-java">Set&lt;E&gt;</code>, <code class="language-java">Queue&lt;E&gt;</code>, <code class="language-java">SortedSet&lt;E&gt;</code>, and <code class="language-java">Deque&lt;E&gt;</code> represent different types of collections. You cannot directly create an object of them since they are just interfaces. But each of them has several implementations. As an example, the <code class="language-java">ArrayList</code> class, that represents a resizable array, is a primary representation of the <code class="language-java">List&lt;E&gt;</code> interface. Other interfaces, as well as their implementations, will be considered in the following topics.</p>
<p>Another root interface is <code class="language-java">Map&lt;K,V&gt;</code> that represents a map (or dictionary) for storing <em><a class="theory-lookup" href="/learn/step/3558" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a key-value pair is a data structure that stores a unique key and a value associated with that key. | It is a fundamental part of the Map interface, which is a collection of such key-value pairs. The key is similar to an index in an array, and the value is the data that is retrieved when the key is used to access it. Key-value pairs are useful in situations where you need to store and retrieve data using a unique identifier. For example, in a phone book, the unique identifier (key) is the name of the contact, and the value associated with that key is the phone number.">key-value pairs</a></em> where <code class="language-java">K</code> is the type of keys and <code class="language-java">V</code> is the type of stored values. In the real world, a good example of a map is a phone book where keys are names of your friends and values are their phones. The <code class="language-java">Map&lt;K,V&gt;</code> interface <strong>is not </strong>a subtype of the <code class="language-java">Collection</code> interface, but maps are often considered as collections since they are part of the collections framework and have similar methods.</p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<div class="alert alert-primary"><p></p><p> </p><p>Note, the <code class="language-java">Collection</code> and <code class="language-java">Map</code> interfaces do not extend each other.</p><p> </p><p></p></div>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h5 id="the-collection-interface">The Collection interface</h5>
<p>Here are common methods provided by the <code class="language-java">Collection</code> interface.</p>
<ul><li><p><code class="language-java">int size()</code> returns the number of elements in this collection;</p></li><li><p><code class="language-java">boolean isEmpty()</code> returns <code class="language-java">true</code> if this collection contains no elements;</p></li><li><p><code class="language-java">boolean contains(Object o)</code> returns <code class="language-java">true</code> if this collection contains the specified element;</p></li><li><p><code class="language-java">boolean add(E e)</code> adds an element to the collection. Returns <code class="language-java">true</code>, if the element was added, else returns <code class="language-java">false</code>;</p></li><li><p><code class="language-java">boolean remove(Object o)</code> removes a single instance of the specified element;</p></li><li><p><code class="language-java">boolean removeAll(Collection&lt;?&gt; collection)</code> removes elements from this collection that are also contained in the specified collection;</p></li><li><p><code class="language-java">void clear()</code> removes all elements from this collection.</p></li></ul>
<p>It is possible to refer to any particular collection via this base interface since, as you know, the <a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a superclass is the class from which a subclass is derived. | It is also known as a base class or a parent class. Inheritance is the mechanism by which one class acquires the properties (fields) and behaviors (methods) of another. With inheritance, the subclass inherits all the public and protected fields and methods from the superclass. A subclass can also add new fields and methods, and the inherited and added members will be used in the same way. A superclass serves as a blueprint for the subclass, providing it with inherited fields and methods. A parent class can have multiple child classes, but a child class can only have one parent class due to Java's single inheritance feature. The parent class reference can be used to refer to an object of the subclass. To derive a new class from another, the keyword extends is used. The common syntax is shown below. It is important to note that Java does not support multiple-class inheritance, meaning that a class can only inherit from a single superclass. A class hierarchy can have multiple levels (a class can extend a class that extends a class), and a superclass can have more than one subclass. A subclass inherits all public and protected fields and methods from the superclass.">superclass</a> can be used to refer to any <a class="theory-lookup" href="/learn/step/3585" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a subclass object refers to an object that is an instance of a subclass, which is a class that is derived from another class, also known as a superclass. | There are two ways to refer to a subclass object: using a subclass reference or using a superclass reference. When using a superclass reference to refer to a subclass object, you need to be aware that you cannot invoke methods or fields of the subclass, only those of the superclass. However, you can always cast an object of a subclass to a superclass, as long as the object is indeed an instance of the subclass.">subclass object</a> derived from that superclass.</p>
<p>Let's create a collection <code class="language-java">languages</code> and add three elements to it:</p>
<pre><code class="language-java">Collection&lt;String&gt; languages = new ArrayList&lt;&gt;();

languages.add("English");
languages.add("Deutsch");
languages.add("Français");

System.out.println(languages.size()); // 3</code></pre>
<p>This approach allows you to replace the concrete collection at any time without changing the code that uses it. It also fosters software reuse by providing a standard interface for collections and algorithms to manipulate them. It may sound complicated now, but the more you work with collections, the more understandable it will become.</p>
<p>It is impossible to get an element by index via the <code class="language-java">Collection</code> interface because it is very abstract and does not provide such a method. But if it doesn't matter to you which particular collection to use, you can work via this interface.</p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<div class="alert alert-warning"><p></p><p> </p><p>It is important to understand that the order of the elements in the <code class="language-java">ArrayList</code> is still preserved. We simply cannot call the <code class="language-java">get</code> method via the <code class="language-java">Collection</code> interface.</p><p> </p><p></p></div>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>Every collection can be cast to a string by using <code class="language-java">toString</code> and compared with another collection using the <code class="language-java">equals</code> method. These methods come from <code class="language-java">Object</code> and their behavior depends on elements stored in the collection and the type of the collection itself.</p>
<h5 id="mutable-and-immutable-collections">Mutable and Immutable collections</h5>
<p>All collections can be divided into two large groups: mutable and immutable. They both implement the <code class="language-java">Collection&lt;E&gt;</code> interface, but immutable collections will throw an <code class="language-java">UnsupportedOperationException</code> when you try to invoke some methods which change them: for example, <code class="language-java">add</code>, <code class="language-java">remove</code>, <code class="language-java">clear</code>.</p>
<p>In the next topics, we will consider how to create and when to use immutable collections. Now just remember that they exist.</p>
<h5 id="iterating-over-collections">Iterating over collections</h5>
<p>If you would like to <a class="theory-lookup" href="/learn/step/3602" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an iterator is an object that enables you to traverse through a collection of elements and access them sequentially. | It is like a moveable pointer to an element of the collection. Iterators allow you to remove elements from the underlying collection, but this cannot be done using a for-each loop. The iterator interface includes methods such as hasNext() to check if the iteration has more elements, next() to return the next element in the iteration, and remove() to delete the current element in the iteration.">iterate</a> over all elements of <em>any </em>collection, you can use the <em>for-each</em> style loop. Let's return to our <code class="language-java">languages</code> collection:</p>
<pre><code class="language-java">for (String lang : languages) {
    System.out.println(lang);
}</code></pre>
<p>This code prints all elements of this collection.</p>
<pre><code class="language-no-highlight">English
Deutsch
Français</code></pre>
<p>The order of elements when iterating depends on the particular type of collection that is actually being used.</p>
<p>If you are already familiar with <a class="theory-lookup" href="/learn/step/3620" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a method reference is a way to refer to a specific method by its name, which can be invoked at any time it is needed. | It is a more readable and easier to test alternative to lambda expressions. Method references can refer to both standard and custom methods. There are four kinds of method references: reference to a static method, reference to an instance method of an existing object, reference to an instance method of an object of a particular type, and reference to a constructor. For example, a reference to a static method can be created using the following general form: `ContainingClass::staticMethodName`.">method references</a> or<em> </em>lambda expressions, you can use another style for iterations using the <code class="language-java">forEach(Consumer&lt;T&gt; consumer)</code> method:</p>
<pre><code class="language-java">languages.forEach(System.out::println); // with method reference
languages.forEach(elem -&gt; System.out.println(elem)); // with lambda expression</code></pre>
<p>This looks very readable but is optional for use.</p>
<h5 id="removing-elements">Removing elements</h5>
<p>It is also possible to remove elements from a mutable collection (like <code class="language-java">ArrayList</code>).</p>
<pre><code class="language-java">languages.remove("Deutsch");

System.out.println(languages.size()); // 2</code></pre>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<div class="alert alert-primary"><p></p><p> </p><p>Note, the <code class="language-java">remove</code> as well as the <code class="language-java">contains</code> methods rely on the <code class="language-java">equals</code> method of the elements. If you store non-standard classes in the collection, <code class="language-java">equals</code> and <code class="language-java">hashCode</code> should be overridden.</p><p> </p><p></p></div>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>Again, if you are already familiar with lambda expressions, you can invoke the <code class="language-java">removeIf</code> method to remove all of the elements that satisfy the given predicate:</p>
<pre><code class="language-java">languages.removeIf(lang -&gt; lang.startsWith("E")); // it removes English

System.out.println(languages.size()); // 1</code></pre>
<p>Use any way you like.</p>
<h5 id="conclusion">Conclusion</h5>
<p>The Java collections framework<strong> </strong>provides a set of interfaces with common methods for different types of collections. We've considered the <code class="language-java">Collection&lt;E&gt;</code> interface which is an abstract container for storing values of the same type. Any particular collection (excluding maps) can be used in a program and iterated through by using the <em>for-each</em> loop or the <code class="language-java">forEach</code> method.</p>
<p>For now, we confine ourselves to this much. All other interfaces including <code class="language-java">Map&lt;K,V&gt;</code> will be considered in the following topics.</p>
</div>
